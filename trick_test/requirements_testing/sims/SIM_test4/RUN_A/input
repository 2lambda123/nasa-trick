#include "S_default.dat"
#include "Modified_data/realtime.d"
#include "Modified_data/test4.dr"

// ###################################################################
// PURPOSE:
// Test Trick MALFUNCTION TRIGGER
// ###################################################################

STOP = 5.0 ;

// ----------------------------------------------------------
// Malfunction "malf_1" tests a TRIGGER CONDITION which:
// * uses a LOGICAL operator
// * is evaluated BEFORE the associated job
// * is NOT held TRUE.
// ----------------------------------------------------------
BEGIN_MALFUNCTION malf_1 {
        TRIGGER {
                CONDITION: sys.exec.out.time == 1.0;
                INSERT_BEFORE: dyn.sched_job_1(&dyn.test4) ;
        }
        ACTION {
                INSERT_BEFORE: dyn.sched_job_1(&dyn.test4) ;
                printf("############################### ACTION FOR  malf_1.\n");
                // Make this a one shot trigger
                MALFUNCTION_CMD malf_1 DISABLE_TRIGGER ;
        }
} ;

// ----------------------------------------------------------
// Malfunction "malf_2" tests a TRIGGER CONDITION which:
// * uses a LOGICAL operator
// * is evaluated AFTER the associated job
// * is held TRUE.
// ----------------------------------------------------------
BEGIN_MALFUNCTION malf_2 {
        TRIGGER {
                CONDITION: sys.exec.out.time == 2.0;
                INSERT_AFTER: dyn.sched_job_2(&dyn.test4) ;
                HOLD: Yes ;
        }
        ACTION {
                INSERT_BEFORE: dyn.sched_job_2(&dyn.test4) ;
                printf("############################### ACTION FOR  malf_2.\n");
                // Make this a one shot trigger
                MALFUNCTION_CMD malf_2 DISABLE_TRIGGER ;
        }
} ;

// ----------------------------------------------------------
// Malfunction "malf_3" tests a TRIGGER CONDITION which:
// * uses a TRIP operator
// * is evaluated BEFORE the associated job
// * is held TRUE.
// ----------------------------------------------------------
BEGIN_MALFUNCTION malf_3 {
        TRIGGER {
                CONDITION: sys.exec.out.time TRIP: 3.0;
                INSERT_BEFORE: dyn.sched_job_3(&dyn.test4) ;
                HOLD: Yes ;
        }
        ACTION {
                INSERT_BEFORE: dyn.sched_job_3(&dyn.test4) ;
                printf("############################### ACTION FOR  malf_3.\n");
                // Make this a one shot trigger
                MALFUNCTION_CMD malf_3 DISABLE_TRIGGER ;
        }
} ;

// ----------------------------------------------------------
// Malfunction "malf_4" tests a TRIGGER CONDITION which:
// * uses a TRIP operator
// * is evaluated AFTER the associated job
// * is NOT held TRUE.
// ----------------------------------------------------------
BEGIN_MALFUNCTION malf_4 {
        TRIGGER {
                CONDITION: sys.exec.out.time TRIP: 4.0;
                INSERT_AFTER: dyn.sched_job_4(&dyn.test4) ;
                HOLD: No ;
        }
        ACTION {
                INSERT_BEFORE: dyn.sched_job_4(&dyn.test4) ;
                printf("############################### ACTION FOR  malf_4.\n");
                // Make this a one shot trigger
                MALFUNCTION_CMD malf_4 DISABLE_TRIGGER ;
        }
} ;

// ----------------------------------------------------------
// TOLERANCE tests:
// "malf_5" and "malf_6" test TOLERANCE in a TRIGGER CONDITION.
// The trigger conditions of both are met when the function
// 1/exp(time) decays to the point that it is close to 0
// ( as determined by TOLERANCE.) 
// NOTE: 1/exp(time) == TOLERANCE at time = ln (1/TOLERANCE).
// For TOLERANCE = 0.1, time = 2.30258, so trigger should happen
// when sys.exec.out.time = 2.4.
// For TOLERANCE = 0.01, time = 4.60517, so trigger should happen
// when sys.exec.out.time = 4.7.
// ----------------------------------------------------------
BEGIN_MALFUNCTION malf_5 {
        TRIGGER {
                CONDITION: dyn.test4.inv_exp_t == 0.0 TOLERANCE: 0.1;
                INSERT_AFTER: dyn.sched_job_2(&dyn.test4) ;
                HOLD: No ;
        }
        ACTION {
                INSERT_AFTER: dyn.sched_job_2(&dyn.test4) ;
                printf("############################### ACTION FOR  malf_5.\n");
                // Make this a one shot trigger
                MALFUNCTION_CMD malf_5 DISABLE_TRIGGER ;
        }
} ;

BEGIN_MALFUNCTION malf_6 {
        TRIGGER {
                CONDITION: dyn.test4.inv_exp_t == 0.0 TOLERANCE: 0.01;
                INSERT_AFTER: dyn.sched_job_2(&dyn.test4) ;
                HOLD: No ;
        }
        ACTION {
                INSERT_AFTER: dyn.sched_job_2(&dyn.test4) ;
                printf("############################### ACTION FOR  malf_6.\n");
                // Make this a one shot trigger
                MALFUNCTION_CMD malf_6 DISABLE_TRIGGER ;
        }
} ;

// ----------------------------------------------------------
// SLOPE tests:
// "malf_7" and "malf_8" test SLOPE in a TRIGGER CONDITION.
// Note that SLOPE is only used with TRIP:.
// The trigger condition of malf_7 is met when the function
// cos(PI* time) == 0 and its slope is positive, so trigger
// should happen when sys.exec.out.time = 1.5.
// The trigger condition of malf_8 is met when the function
// cos(PI* time) == 0 and its slope is negative, so trigger
// should happen when sys.exec.out.time = 0.5.
// ----------------------------------------------------------
BEGIN_MALFUNCTION malf_7 {
        TRIGGER {
                CONDITION: dyn.test4.cos_pi_t TRIP: 0.0 ;
                INSERT_AFTER: dyn.sched_job_1(&dyn.test4) ;
                HOLD: No ;
        }
        ACTION {
                INSERT_AFTER: dyn.sched_job_1(&dyn.test4) ;
                printf("############################### ACTION FOR  malf_7.\n");
                // Make this a one shot trigger
                MALFUNCTION_CMD malf_7 DISABLE_TRIGGER ;
        }
} ;

BEGIN_MALFUNCTION malf_8 {
        TRIGGER {
                CONDITION: dyn.test4.cos_pi_t TRIP: 0.0 ;
                INSERT_AFTER: dyn.sched_job_1(&dyn.test4) ;
                HOLD: Yes ;
        }
        ACTION {
                INSERT_AFTER: dyn.sched_job_1(&dyn.test4) ;
                printf("############################### ACTION FOR  malf_8.\n");
                // Make this a one shot trigger
                MALFUNCTION_CMD malf_8 DISABLE_TRIGGER ;
        }
} ;

// ----------------------------------------------------------
// Trigger Jobs:
// "malf_9" trigger job "dyn.trigger_job_1" returns TRUE when
// the value cos_pi_t changes sign (passes through zero).   
// ----------------------------------------------------------
BEGIN_MALFUNCTION malf_9 {
        TRIGGER {
                JOB: dyn.trigger_job_1(&dyn.test4) ;
                INSERT_AFTER: dyn.sched_job_1(&dyn.test4) ;
                HOLD: No ;
        }
        ACTION {
                INSERT_AFTER: dyn.sched_job_1(&dyn.test4) ;
                printf("############################### ACTION FOR  malf_9.\n");
                // Make this a one shot trigger
                // MALFUNCTION_CMD malf_9 DISABLE_TRIGGER ;
        }
} ;


// ----------------------------------------------------------
// Action = <variable> ...
// ----------------------------------------------------------

BEGIN_MALFUNCTION malf_10 {
        TRIGGER {
                CONDITION: sys.exec.out.time == 2.0 ;
                INSERT_AFTER: dyn.sched_job_1(&dyn.test4) ;
                HOLD: No ;
        }
        dyn.test4.velocity {
            UNITS: {m/s} ;
            SCALE_FACTOR: 1.0 ;
            BIAS: 1.0 ;
        }
} ;

// ----------------------------------------------------------
// Action = CALL <malfunction_jobname> BEFORE|AFTER <associated_jobname> [(duplication_id)] ;
// ----------------------------------------------------------

BEGIN_MALFUNCTION malf_11 {
        TRIGGER {
                CONDITION: sys.exec.out.time == 3.0 ;
                INSERT_AFTER: dyn.sched_job_1(&dyn.test4) ;
                HOLD: No ;
        }
        CALL dyn.malf_job_1(&dyn.test4) BEFORE  dyn.sched_job_5(&dyn.test4)(1) ;
} ;

BEGIN_MALFUNCTION malf_12 {
        TRIGGER {
                CONDITION: sys.exec.out.time == 4.0 ;
                INSERT_AFTER: dyn.sched_job_1(&dyn.test4) ;
                HOLD: No ;
        }
        CALL dyn.malf_job_2(&dyn.test4) AFTER dyn.sched_job_5(&dyn.test4)(2) ;
} ;

// ----------------------------------------------------------
// Action = JOB <any_job> = On | Off ;
// ----------------------------------------------------------
BEGIN_MALFUNCTION malf_12 {
        TRIGGER {
                CONDITION: sys.exec.out.time == 4.0 ;
                INSERT_AFTER: dyn.sched_job_1(&dyn.test4) ;
                HOLD: No ;
        }
        CALL dyn.malf_job_2(&dyn.test4) AFTER dyn.sched_job_5(&dyn.test4)(2) ;
} ;
